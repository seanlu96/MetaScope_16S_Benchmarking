---
title: "mock_microbiome_analysis"
author: "Sean Lu"
date: "`r Sys.Date()`"
output: pdf_document
editor_options:
  chunk_output_type: console
---
```{r knitr options, include = FALSE}
knitr::opts_chunk$set(cache=FALSE, cache.path=".cache/")
```

## Setup
```{r Loading in Libraries, message=FALSE}
library("tidyverse")
library("phyloseq")
library("ggpubr")
library("DESeq2")
library("ggsci")
library("colorspace")
library("flextable")
library("pracma")
library("purrr")
library("paletteer")
```

## Summarize MetaScope Results
```{r Summarize MetaScope Results}

ground_truth_taxonomy <- read.csv("data_processed/kozich_2013/ground_truth_taxonomy.csv", 
                      head = TRUE)
species_ground_truth <- ground_truth_taxonomy$species
accessions_path <- "reflib/accessionTaxa.sql"

## Code used to generate ground truth taxids
#ground_truth_taxids <- ground_truth_taxonomy |> 
#  tidyr::pivot_longer(everything(), names_to = "Taxonomy Level", values_to = "taxon") |> 
#  dplyr::distinct(taxon, .keep_all = TRUE) |>
#  mutate(taxid = taxonomizr::getId(taxon, sqlFile = accessions_path)) |>
#  rowwise() |>
#  mutate(taxid = as.numeric(strsplit(taxid, split = ",")[[1]][1]))
#write.csv(ground_truth_taxids, 
#          file = "data_processed/kozich_2013/ground_truth_taxids.csv",
#          row.names = FALSE)
ground_truth_taxids <- read.csv("data_processed/kozich_2013/ground_truth_taxids.csv",)

# Function used to read MetaScope outputs and generate cleaned accuracy metrics
create_summary_df <- function(csv_paths, pipeline_name) {
  summary_df <- data.frame(
    Species = c("No Call", "Incorrect Call",species_ground_truth))
  n = 1
  for (i in csv_paths) {
    # Get Sample Names
    sample_name <- sub("\\..*$", "", basename(i))
    # Clean MetaBlast Table
    metascope_df <- read.csv(i, head = TRUE)
    head(metascope_df)
    metascope_df <- metascope_df |>
      dplyr::select(Genome, read_count) |>
      dplyr::mutate_if(is.numeric, ~ . / sum(.))
    colnames(metascope_df) <- c("Species", sample_name)
    summary_df <- dplyr::left_join(summary_df, metascope_df, by = "Species")
    summary_df[is.na(summary_df)] <- 0
    
    no_call.metascope <- metascope_df |>
      dplyr::filter(is.na(Species)) |>
      dplyr::select(sample_name) |>
      sum()
    correct_call.metascope <- metascope_df |>
      dplyr::filter(Species %in% species_ground_truth) |>
      dplyr::select(sample_name) |>
      sum()
    incorrect_call.metascope <- 1 - correct_call.metascope - no_call.metascope
    
    summary_df[1,n+1] <- no_call.metascope
    summary_df[2,n+1] <- incorrect_call.metascope
    n = n + 1
  } 
  
  
  summary_df_long <- tidyr::pivot_longer(
    summary_df, 
    cols = c(2:ncol(summary_df)), 
    values_to = "prop"
  )
  summary_df_long$Species <- factor(summary_df_long$Species, 
                                    levels = c("No Call", "Incorrect Call", species_ground_truth))
  summary_df_long$name <- factor(summary_df_long$name)
  summary_df_long$pipeline <- factor(rep(pipeline_name, nrow(summary_df_long)))
  return(summary_df_long)
}

## Generate Summary dataframes for all metascope outputs
ms_df <- create_summary_df(list.files(path = "data_processed/kozich_2013/results", 
                             pattern = ".metascope_id.csv", 
                             full.names = TRUE, 
                             recursive = TRUE),
                  pipeline = "MetaScope")
ms_p_df <-create_summary_df(list.files(path = "data_processed/kozich_2013/results_priors", 
                             pattern = ".metascope_id.csv", 
                             full.names = TRUE, 
                             recursive = TRUE),
                  pipeline = "MetaScope Priors")
ms_p_b_df <-create_summary_df(list.files(path = "data_processed/kozich_2013/results_metablast_priors_1.0", 
                             pattern = ".metascope_id.csv", 
                             full.names = TRUE, 
                             recursive = TRUE),
                  pipeline = "MetaBlast")
summary_df <- rbind(ms_df, ms_p_df, ms_p_b_df)

## Add Ground Truth to summary dataframe
ground_truth_df <- data.frame(
  Species = c("No Call", "Incorrect Call",species_ground_truth))
ground_truth_df <- cbind(ground_truth_df, 
                         as.data.frame(do.call(cbind, replicate(33, c(0,0,rep(1/21, 21)), simplify = FALSE))))
colnames(ground_truth_df) <-  c("Species", as.character(unique(summary_df$name)))
ground_truth_df <- tidyr::pivot_longer(
  ground_truth_df, 
  cols = c(2:34), 
  values_to = "prop"
)
ground_truth_df$pipeline <- "Ground Truth"
summary_df <- rbind(summary_df, ground_truth_df)
```

# Summarize DADA2 Results
```{r Summarize DADA2 Results}
##Left joining with aggregate because duplicate species names
dada2_files <- list.files(path = "data_processed/kozich_2013/dada2_results",
                          full.names = TRUE)
taxonomy_cols <- c("Species", "Genus", "Family", "Order", "Class", "Phylum", "Kingdom")

## Join DADA2 Files together
dada2_df <- purrr::map_dfr(dada2_files, function(x){
  sample_name <- sub("\\..*$", "", basename(x)) |> strsplit(split = "dada2_")
  sample_name <- sample_name[[1]][2]
  res <- read.csv(x) |>
    dplyr::mutate(Species = ifelse(is.na(Species), NA, paste0(Genus, " ", Species))) |>
    dplyr::mutate_if(is.numeric, ~ . / sum(.)) |>
    dplyr::mutate(pipeline = "DADA2-NB", name = sample_name) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      taxon = {
        tax_vals <- c_across(all_of(taxonomy_cols))
        non_na_vals <- tax_vals[!is.na(tax_vals)]
        if (length(non_na_vals) > 0) non_na_vals[1] else NA_character_
      }
    ) |>
    dplyr::ungroup()
})

## Clean up old taxonomy names
dada2_df$taxon[dada2_df$taxon == "Bacteroides vulgatus"] <- 'Phocaeicola vulgatus'
dada2_df$taxon[dada2_df$taxon == 'Actinomyces odontolyticus'] <- "Schaalia odontolytica"
dada2_df$taxon[dada2_df$taxon == "Propionibacterium acnes"] <- 'Cutibacterium acnes'
dada2_df$taxon[dada2_df$taxon == "Rhodobacter sphaeroides"] <- 'Cereibacter sphaeroides'
dada2_df$taxon[dada2_df$taxon == "Clostridium sensu stricto 1 beijerinckii"] <- 'Clostridium beijerinckii'
dada2_df$taxon[dada2_df$taxon == "Escherichia-Shigella"] <- 'Escherichia' # Assuming DADA2 meant Escherichia, both are separate genera
dada2_df$taxon[dada2_df$taxon == "Prevotella_9"] <- 'Segatella'
dada2_df$taxon[dada2_df$taxon == "Prevotella_9 copri"] <- 'Segatella copri'
dada2_df$taxon[dada2_df$taxon == "Rhodobacteraceae"] <- 'Paracoccaceae'
dada2_df$taxon[dada2_df$taxon == "Bacteroides massiliensis"] <- 'Phocaeicola massiliensis'
dada2_df$taxon[dada2_df$taxon == "Ruminococcaceae"] <- 'Oscillospiraceae'
dada2_df$taxon[dada2_df$taxon == "Clostridium sensu stricto 1"] <- 'Clostridium'
dada2_df$taxon[dada2_df$taxon == "Planococcaceae"] <- 'Caryophanaceae'


## Add NCBI taxonomy ids
dada2_df <- dada2_df |>
  mutate(taxid_raw = taxonomizr::getId(taxon, sqlFile = accessions_path)) |>
  rowwise() |>
  mutate(taxid = as.numeric(strsplit(taxid_raw, split = ",")[[1]][1])) |>
  ungroup() |>
  mutate(taxid = if_else(is.na(taxid), 9999999, taxid)) |> # REPLACING ALL UNKNOWN TAXONS WITH TAXID 9999999
  dplyr::select(!taxid_raw)

## Adding categories
dada2_df_cats <- dada2_df |>
  dplyr::mutate(category = case_when(
    (taxid %in% ground_truth_taxids$taxid) & !is.na(Species) ~ taxon,
    (taxid %in% ground_truth_taxids$taxid) & is.na(Species) ~ "No Call",
    !(taxid %in% ground_truth_taxids$taxid) ~ "Incorrect Call")) |>
  dplyr::group_by(category, name) |>
  dplyr::summarise(prop = sum(reads_count))
dada2_df_cats$pipeline = "DADA2-NB"
colnames(dada2_df_cats) <- c("Species", "name", "prop", "pipeline")

#write.csv(dada2_df_cats, file = "data_processed/kozich_2013/dada2_df.csv",
#         row.names = FALSE)

summary_df <- rbind(summary_df, dada2_df_cats)
```

# Summarize QIIME2 Results
```{r Summarize QIIME2 Results} 
summary_df_qiime2 <- data.frame(
  Species = c("No Call", "Incorrect Call",species_ground_truth))

qiime2_otu_table <- read.table("data_processed/kozich_2013/qiime2_results/feature_table.tsv",
           header = TRUE, sep = "\t") |>
  dplyr::mutate_if(is.numeric, ~ . / sum(.)) |>
  pivot_longer(cols = !OTU.ID)

taxonomy_cols <- c("Species", "Genus", "Family", "Order", "Class", "Phylum", "Superkingdom")
qiime2_tax_table <- read.table("data_processed/kozich_2013/qiime2_results/taxonomy.tsv",
                               header = TRUE, sep = "\t") |>
  separate(Taxon, into = c("Superkingdom", "Phylum", "Class",
                           "Order", "Family", "Genus", "Species"),
           sep = ";", fill = "right", extra = "drop") |>
  mutate(across(Superkingdom:Species, ~ str_remove(., "^\\s*[a-z]__"))) |>
  mutate(Species = sub("_", " ", Species)) |>
  rowwise() |>
  mutate(
    taxon = {
      tax_vals <- c_across(all_of(taxonomy_cols))
      non_na_vals <- tax_vals[!is.na(tax_vals)]
      if (length(non_na_vals) > 0) non_na_vals[1] else NA_character_0}) |>
  ungroup()

# Manually Address NAs
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Clostridium_sensu_stricto_1"] <- "Clostridium"
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Escherichia-Shigella"] <- "Escherichia" # Escherichia and Shigella are different genera. Giving qiime2 the benefit of the doubt and saying its assigning to the correct genus Escherichia
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Bacteroides vulgatus"] <- "Phocaeicola vulgatus"
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Bacteroides massiliensis"] <- "Phocaeicola massiliensis"
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Alistipes obesi"] <- "Alistipes communis"
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Candidatus_Udaeobacter"] <- "Candidatus Udaeobacter"
qiime2_tax_table$taxon[qiime2_tax_table$taxon == "Ruminococcaceae"] <- "Oscillospiraceae"

# Add taxids to QIIME2 taxonomy table
qiime2_tax_table <- qiime2_tax_table |>
  mutate(taxid_raw = taxonomizr::getId(taxon, sqlFile = accessions_path)) |>
  rowwise() |>
  mutate(taxid = as.numeric(strsplit(taxid_raw, split = ",")[[1]][1])) |>
  ungroup() |>
  mutate(taxid = if_else(is.na(taxid), 9999999, taxid)) |> # REPLACING ALL UNKNOWN TAXONS WITH TAXID 9999999
  dplyr::select(!taxid_raw)


qiime2_df <- full_join(qiime2_otu_table, qiime2_tax_table, by=join_by(OTU.ID == Feature.ID))


qiime2_df_cats <- qiime2_df |>
  dplyr::mutate(category = case_when(
    (taxid %in% ground_truth_taxids$taxid) & !is.na(Species) ~ taxon,
    (taxid %in% ground_truth_taxids$taxid) & is.na(Species) ~ "No Call",
    !(taxid %in% ground_truth_taxids$taxid) ~ "Incorrect Call")) |>
  dplyr::group_by(category, name) |>
  dplyr::summarise(prop = sum(value))
qiime2_df_cats$pipeline <- "QIIME2"
colnames(qiime2_df_cats) <- c("Species", "name", "prop", "pipeline")

summary_df_qiime2 <-
  expand.grid(Species = c("No Call", "Incorrect Call", species_ground_truth),
            name = unique(qiime2_df_cats$name),
            stringsAsFactors = TRUE) |>
  merge(qiime2_df_cats, by = c("Species", "name"), all.x = TRUE) |>
  replace_na(list(prop = 0, pipeline = "QIIME2"))

#write.csv(summary_df_qiime2, file = "data_processed/kozich_2013/qiime2_df.csv",
#          row.names = FALSE)
summary_df <- rbind(summary_df, summary_df_qiime2)
```

# Plotting Relative Abundance of Mock Microbiome             

```{r relab plot, echo=FALSE, fig.align = 'center'}
summary_df$Species <- factor(summary_df$Species, 
                                   levels = c("No Call", 
                                              "Incorrect Call", 
                                              species_ground_truth))
summary_df$pipeline <- factor(summary_df$pipeline,
                                    levels = c("Ground Truth",
                                               "QIIME2",
                                               "DADA2-NB", 
                                               "MetaScope", 
                                               "MetaScope Priors", 
                                               "MetaBlast"))

num_colors <- 21
#wheel_colors <- colorspace::qualitative_hcl(num_colors, palette = "Dark3")
wheel_colors <- paletteer::paletteer_d("khroma::soil", num_colors)
wheel_colors <- append(wheel_colors, c("grey85", "grey75"), after = 0)

p1 <- ggplot(data = summary_df  , aes(fill = Species, y = prop, x = name)) +
  geom_bar(position ="stack", stat = "identity")+
  scale_fill_manual(values = wheel_colors, name = "Species") + 
  ylab("Relative Abundance") + 
  xlab("") +
  scale_y_continuous(breaks = seq(0,1, by = 0.1)) +
  facet_grid(~pipeline) + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
plot(p1)               
```

## Exporting for Figures
```{r Exporting for Figures, eval=FALSE}
p1 <- ggplot(data = summary_df  , aes(fill = Species, y = prop, x = name)) +
  theme_gray(base_size = 7) +
  geom_bar(position ="stack", stat = "identity")+
  scale_fill_manual(values = wheel_colors, name = "Species") + 
  ylab("Relative Abundance") + 
  xlab("Samples") +
  scale_y_continuous(breaks = seq(0,1, by = 0.1)) +
  facet_grid(~pipeline) + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.key.size=unit(3,"mm"),
        text=element_text(size=6))+ 
  guides(fill=guide_legend(nrow=15,byrow=TRUE))

ggsave(filename="figures/p1_stacked_relab_qdms.svg", plot=p1, dpi=450, 
       width=180,height=90,units="mm",device="svg")


```

## Accuracy Tables
```{r Accuracy Tables, echo=FALSE}
calculate_accuracy_metrics <- function(profiler) {
  correct_call <- summary_df |> 
    dplyr::filter(!(Species %in% c("Incorrect Call", "No Call"))) |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::group_by(name) |>
    dplyr::summarise(total_prop = sum(prop)) |>
    dplyr::pull(total_prop) |>
    mean() |>
    round(digits =3)
  correct_call_sd <- summary_df |> 
    dplyr::filter(!(Species %in% c("Incorrect Call", "No Call"))) |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::group_by(name) |>
    dplyr::summarise(total_prop = sum(prop)) |>
    dplyr::pull(total_prop) |>
    sd(na.rm = TRUE)|>
    round(digits = 3)
  no_call <- summary_df |>
    dplyr::filter(Species == "No Call") |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::pull(prop) |>
    mean()|>
    round(digits = 3)
  no_call_sd <- summary_df |>
    dplyr::filter(Species == "No Call") |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::pull(prop) |>
    sd(na.rm = TRUE)|>
    round(digits = 3)
  incorrect_call <- summary_df |>
    dplyr::filter(Species == "Incorrect Call") |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::pull(prop) |>
    mean()|>
    round(digits = 3)
  incorrect_call_sd <- summary_df |>
    dplyr::filter(Species == "Incorrect Call") |>
    dplyr::filter(pipeline == profiler) |>
    dplyr::pull(prop) |>
    sd(na.rm = TRUE)|>
    round(digits = 3)
  all_res <- c(correct_call, correct_call_sd, no_call, no_call_sd, 
               incorrect_call,incorrect_call_sd)
  names(all_res) <- c("correct_call", "correct_call_sd", "no_call", 
                      "no_call_sd", "incorrect_call","incorrect_call_sd")
  return(all_res)
}

qiime2_metrics <- calculate_accuracy_metrics("QIIME2")
dada2_metrics <- calculate_accuracy_metrics("DADA2-NB")
metascope_metrics <- calculate_accuracy_metrics("MetaScope")
metascope_priors_metrics <- calculate_accuracy_metrics("MetaScope Priors")
metascope_blast_metrics <- calculate_accuracy_metrics("MetaBlast")

table_summary <- tidyr::tibble(
  "Profiler" = c("QIIME2", "DADA2-NB", "MetaScope", "MetaScope Priors", "MetaBlast"),
  "Correct Call" = c(
    paste0(qiime2_metrics[1], " ± ", qiime2_metrics[2]),
    paste0(dada2_metrics[1], " ± ", dada2_metrics[2]),
    paste0(metascope_metrics[1], " ± ", metascope_metrics[2]),
    paste0(metascope_priors_metrics[1], " ± ", metascope_priors_metrics[2]),
    paste0(metascope_blast_metrics[1], " ± ", metascope_blast_metrics[2])),
  "No Call" = c(
    paste0(qiime2_metrics[3], " ± ", qiime2_metrics[4]),
    paste0(dada2_metrics[3], " ± ", dada2_metrics[4]),
    paste0(metascope_metrics[3], " ± ", metascope_metrics[4]),
    paste0(metascope_priors_metrics[3], " ± ", metascope_priors_metrics[4]),
    paste0(metascope_blast_metrics[3], " ± ", metascope_blast_metrics[4])),
  "Incorrect Call" = c(
    paste0(qiime2_metrics[5], " ± ", qiime2_metrics[6]),
    paste0(dada2_metrics[5], " ± ", dada2_metrics[6]),
    paste0(metascope_metrics[5], " ± ", metascope_metrics[6]),
    paste0(metascope_priors_metrics[5], " ± ", metascope_priors_metrics[6]),
    paste0(metascope_blast_metrics[5], " ± ", metascope_blast_metrics[6])),
)

table <- flextable(data = table_summary) |>
  #width(width = 1.25) |>
  bold(bold = TRUE, part = "header") |>
  fontsize(size=6, part="all") |>
  font(fontname="Arial")
table_plot <- table |> gen_grob() |> plot()  
```

```{r Exporting table, eval=FALSE}
ggsave(filename="figures/t1_accuracy_table.svg", plot=table_plot, dpi=450, 
       width=54,height=35,units="mm",device="svg")
```

```{r Accuracy Calculations}
# This metascope is k - 25
p_bar_with_stats<- summary_df |> dplyr::filter(Species %in% c("No Call", "Incorrect Call")) |>
  tidyr::pivot_wider(names_from = Species, values_from = prop, names_repair = "universal") |>
  dplyr::mutate(Correct.Call = 1 - (No.Call + Incorrect.Call)) |>
  dplyr::filter(pipeline != "Ground Truth") |>
  dplyr::group_by(pipeline) |>
  dplyr::group_by(name) |> 
  ggplot(aes(x = pipeline, y = Correct.Call)) +
  geom_violin() + 
  geom_jitter() + 
  ylim(0,1.5) + 
  stat_compare_means(label.y = 1.3, method = "anova", paired = TRUE) +
  stat_compare_means(
    comparisons = list(
      c("DADA2-NB", "QIIME2"), 
      c("DADA2-NB", "MetaScope"), 
      c("MetaScope", "MetaScope Priors"),                             
      c("MetaScope Priors", "MetaBlast")),
    method = "t.test", 
    paired = TRUE)
  
p_bar_with_stats

```

# Sensitivity Analysis 

```{r Sensitivity Analysis }
priors_0<- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "No Priors"
)

priors_0.005 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_0.005", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "0.005"
)

priors_0.01 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_0.01", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "0.01"
)

priors_0.05 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_0.05", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "0.05"
)

priors_0.1 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_0.1", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "0.1"
)

priors_0.5 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_0.5", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "0.5"
)

priors_1.0 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_1.0", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "1.0"
)

priors_2.0 <- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_priors_2.0", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "2.0"
)


summary_df_sensitivity <- rbind(priors_0, priors_0.005, priors_0.01, priors_0.05, priors_0.1, priors_0.5, priors_1.0, priors_2.0)

summary_df_sensitivity <- rbind(priors_0, priors_0.005, priors_0.01, priors_0.1, priors_1.0)

summary_df_sensitivity |> dplyr::filter(Species %in% c("Correct Call", "Incorrect Call")) |>
  tidyr::pivot_wider(names_from = Species, values_from = prop, names_repair = "universal") |>
  dplyr::mutate(Correct.Call = 1 - as.numeric(Incorrect.Call)) |>
  dplyr::filter(pipeline != "Ground Truth") |>
  dplyr::group_by(pipeline) |>
  dplyr::group_by(name) |> 
  ggplot(aes(x = pipeline, y = Correct.Call)) +
  geom_boxplot() + 
  geom_jitter() +
  #theme(axis.text.x = element_text(angle = 90)) +
  xlab("Sum of total priors") + 
  ylab("Percentage of Correct Calls") +
  stat_compare_means(label.y = 1.0, method = "anova", paired = TRUE) +
  stat_compare_means(comparisons = list(c("No Priors", "0.005"), 
                                        c("0.005", "0.01"), c("0.005", "0.05")), 
                     method = "wilcox.test", 
                     paired = FALSE)

```

```{r}
summary_df_final_3 <- rbind(priors_0, priors_0.005, priors_0.01)
p3 <- ggplot(data = summary_df_final_3  , aes(fill = Species, y = prop, x = name)) +
  geom_bar(position ="stack", stat = "identity")+
  scale_fill_manual(values = wheel_colors, name = "Species") + 
  ylab("Relative Abundance") + 
  xlab("") +
  scale_y_continuous(breaks = seq(0,1, by = 0.1)) +
  facet_grid(~pipeline) + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
plot(p3) 
```

#HMP priors
```{r}
hmp_priors<- create_summary_df(
  list.files(
    path = "data_processed/kozich_2013/results_hmp_priors", 
    pattern = ".metascope_id.csv", 
    full.names = TRUE, 
    recursive = TRUE), 
  pipeline_name = "MetaScope HMP Priors"
)


hmp_test <- rbind(priors_0, hmp_priors, priors_1.0) |>
  dplyr::filter(Species %in% c("No Call", "Incorrect Call")) |>
  tidyr::pivot_wider(names_from = Species, values_from = prop, names_repair = "universal") |>
  dplyr::mutate(Correct.Call = 1 - (No.Call + Incorrect.Call))

ggplot(hmp_test, aes(x=pipeline, y=Correct.Call)) + 
  geom_boxplot() +
  stat_compare_means(label.y = 1.1, label.x = 0.55, method = "anova", paired = TRUE) +
  stat_compare_means(comparisons = list(c("No Priors", "MetaScope HMP Priors"), 
                                        c("No Priors", "1.0"), c("MetaScope HMP Priors", "1.0")), 
                     method = "wilcox.test", 
                     paired = TRUE, 
                     step.increase = .2,
                     symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1), 
                                        symbols = c("****", "***", "**", "*", "ns"))) +
  geom_jitter() + 
  scale_x_discrete(labels=c("1.0" = "Priors 1.0")) +
  scale_y_continuous(breaks=c(0,0.5,1), 
                     limits = c(0,1.2))
```


# Using Vegan to determine distance matrices
```{r}
ground_truth_taxonomy_taxids <- 
  taxonomizr::getId(ground_truth_taxonomy$species,
                             accessions_path)

# Helper function to generate distance metrics from metascope files
dist_ms_to_ground_truth <- function(file_paths, pipeline, distance_metric) {
  dfs_list <- file_paths |>   
    set_names(function(x) sub("\\..*$", "", basename(x))) |>
    map(function(x) {
      df <- read.csv(x)
      sample_name <- sub("\\..*$", "", basename(x))
      df <- df |> 
        select(TaxonomyID,Genome,readsEM) |>
        dplyr::rename(!!paste0(sample_name,".",pipeline) := readsEM)
      return(df)
    })
  dfs_merged <- purrr::reduce(dfs_list, full_join, by = c("TaxonomyID", "Genome")) |>
    mutate(across(where(is.numeric), ~ replace_na(.x, 0))) |>
    dplyr::select(-Genome) |>
  tibble::column_to_rownames("TaxonomyID") |>
  dplyr::mutate_if(is.numeric, ~ . / sum(.))
  
  # Generate Matrix used for vegan::vegdist and full join ground_truth taxonomy
  ms_dist_mat <- full_join(dfs_merged |> 
            tibble::rownames_to_column("TaxonomyID") |>
            mutate(TaxonomyID = as.numeric(TaxonomyID)), 
          data.frame(TaxonomyID = as.numeric(ground_truth_taxonomy_taxids),
                     Ground_Truth = rep(1/length(ground_truth_taxonomy_taxids),
                                    length(ground_truth_taxonomy_taxids))),
          by = "TaxonomyID") |>
  mutate(across(everything(), ~ replace_na(.x, 0))) |>
  column_to_rownames("TaxonomyID") |>
  filter(rowSums(across(where(is.numeric))) > 0) |> 
  t()

  dist_mat <- vegan::vegdist(ms_dist_mat, method = distance_metric) |> as.matrix() |>
    as.data.frame() |>
    filter(row_number() <= n()-1) |>
    pull(Ground_Truth)

  return(dist_mat)
  
}

## Function to generate distances for all outputs
dist_from_ground_truth <- function(distance_metric) {
  ms_dist <- dist_ms_to_ground_truth(list.files(path = "data_processed/kozich_2013/results", 
                               pattern = ".metascope_id.csv", 
                               full.names = TRUE, 
                               recursive = TRUE),
                    pipeline = "MetaScope",
                    distance_metric = distance_metric)
  ms_p_dist <- dist_ms_to_ground_truth(list.files(path = "data_processed/kozich_2013/results_priors", 
                               pattern = ".metascope_id.csv", 
                               full.names = TRUE, 
                               recursive = TRUE),
                    pipeline = "MetaScope Priors",
                    distance_metric = distance_metric)
  ms_p_b_dist <- dist_ms_to_ground_truth(list.files(path = "data_processed/kozich_2013/results_metablast_priors_1.0", 
                               pattern = ".metascope_id.csv", 
                               full.names = TRUE, 
                               recursive = TRUE),
                    pipeline = "MetaBlast",
                    distance_metric = distance_metric)
  
  
  dada2_dist <- dada2_df |> select(name, taxon, taxid, reads_count) |>
    group_by(taxon, taxid, name) |>
    summarise(reads_count = sum(reads_count), .groups = "drop") |>
    pivot_wider(names_from = name, values_from = reads_count, values_fill = 0) |>
    full_join(data.frame(taxid = as.numeric(ground_truth_taxonomy_taxids),
                       Ground_Truth = rep(1/length(ground_truth_taxonomy_taxids),
                                      length(ground_truth_taxonomy_taxids))),
              by = "taxid") |>
    mutate(taxon = if_else(is.na(taxon), taxonomizr::getTaxonomy(taxid, accessions_path, desiredTaxa = c("species")),
                           taxon)) |>
    mutate(across(everything(), ~ replace_na(.x, 0))) |>
    tibble::column_to_rownames("taxon") |> # Using taxon for rowname instead of taxid because I labeled unknown taxids as 999999
    select(-taxid) |>
    t() |>
    vegan::vegdist(method = distance_metric) |>
    as.matrix() |>
    as.data.frame() |>
    filter(row_number() <= n()-1) |> # Remove the last row which contains ground_truth vs ground_truth
    pull(Ground_Truth)
  
  qiime2_dist <- qiime2_df |> 
    select(name, taxon, taxid, value) |>
    group_by(taxon, taxid, name) |>
    summarise(reads_count = sum(value), .groups = "drop") |>
    pivot_wider(names_from = name, values_from = reads_count, values_fill = 0) |>
    full_join(data.frame(taxid = as.numeric(ground_truth_taxonomy_taxids),
                       Ground_Truth = rep(1/length(ground_truth_taxonomy_taxids),
                                      length(ground_truth_taxonomy_taxids))),
              by = "taxid") |>
    mutate(taxon = if_else(is.na(taxon), taxonomizr::getTaxonomy(taxid, accessions_path, desiredTaxa = c("species")),
                           taxon)) |>
    mutate(across(everything(), ~ replace_na(.x, 0))) |>
    tibble::column_to_rownames("taxon") |> # Using taxon for rowname instead of taxid because I labeled unknown taxids as 999999
    select(-taxid) |>
    t() |>
    vegan::vegdist(method = distance_metric) |>
    as.matrix() |>
    as.data.frame() |>
    filter(row_number() <= n()-1) |> # Remove the last row which contains ground_truth vs ground_truth
    pull(Ground_Truth)
  
  merged_res <- tibble(
    "QIIME2" = qiime2_dist,
    "DADA2-NB" = dada2_dist,
    "MetaScope" = ms_dist,
    "MetaScope Priors" = ms_p_dist,
    "MetaBlast" = ms_p_b_dist,
    "distance_method" = distance_metric) |>
  pivot_longer(cols = c("QIIME2","DADA2-NB","MetaScope","MetaScope Priors", "MetaBlast"), 
               names_to = "pipeline", values_to = "distance_from_ground_truth")
  merged_res$pipeline <-factor(merged_res$pipeline,
                               levels = c("QIIME2", "DADA2-NB", "MetaScope", 
                                          "MetaScope Priors", "MetaBlast"))
  return(merged_res)
}

distance_res <- map_dfr(c("bray", "jaccard", "euclidean"), dist_from_ground_truth)


p4 <- ggplot(distance_res, aes(x = pipeline, y = distance_from_ground_truth, color=pipeline)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(size=0.25) + 
  facet_grid(~distance_method) + 
  xlab("Pipeline") + 
  ylab("Distance from Ground Truth") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        text=element_text(size=6))
p4
distance_res |> 
  group_by(distance_method, pipeline) |>
  summarise(mean = mean(distance_from_ground_truth),
            sd = sd(distance_from_ground_truth))
```

```{r Saving beta diversity, eval=FALSE}
ggsave(filename="figures/p4_beta_diversity.svg", plot=p4, dpi=450, 
       width=88,height=58,units="mm",device="svg")
```

```{r Precision, Recall, F1}
# Helper function to read MetaScope results
read_ms_results <- function(file_paths, pipeline) {
  dfs_list <- file_paths |>   
    set_names(function(x) sub("\\..*$", "", basename(x))) |>
    map(function(x) {
      df <- read.csv(x)
      sample_name <- sub("\\..*$", "", basename(x))
      df <- df |> 
        select(TaxonomyID,Genome,readsEM) |>
        dplyr::rename(!!sample_name := readsEM)
      return(df)
    })
  dfs_merged <- purrr::reduce(dfs_list, full_join, by = c("TaxonomyID", "Genome")) |>
    mutate(across(where(is.numeric), ~ replace_na(.x, 0))) |>
    dplyr::select(-Genome) |>
  tibble::column_to_rownames("TaxonomyID") |>
  dplyr::mutate_if(is.numeric, ~ . / sum(.))
  return(dfs_merged)
}

# Helper Function to calculate precision, recall, and F1 and species level 
#  relative abundance threshold
calc_prf <- function(abundance_threshold) {
  dada2_prf <- dada2_df |> 
    group_by(name, taxid) |>
    summarise(value = sum(reads_count), .groups = "drop") |>  # Merge same sample and taxids together
    filter(value > abundance_threshold) |>
    mutate(abund_weight = 1 - abs(value - 1/21),
           is_tp = taxid %in% ground_truth_taxonomy_taxids) |> # weight by distance from ground truth abundance
    group_by(name) |> 
    summarise(
      TP = sum(is_tp),
      precision = TP / n(),
      recall = TP / length(ground_truth_taxonomy_taxids),
      F1 = 2 * precision * recall / (precision + recall)) |>
    mutate(pipeline = "DADA2-NB")
  
  qiime2_prf <- qiime2_df |> 
    group_by(name, taxid) |>
    summarise(value = sum(value), .groups = "drop") |> 
    filter(value > abundance_threshold) |>
    mutate(abund_weight = 1 - abs(value - 1/21),  # weight by distance from ground truth abundance
           is_tp = taxid %in% ground_truth_taxonomy_taxids) |>
    group_by(name) |>
    summarise(
      TP = sum(is_tp * abund_weight),
      precision = TP / n(),
      recall = TP / length(ground_truth_taxonomy_taxids),
      F1 = 2 * precision * recall / (precision + recall)) |>
    mutate(pipeline = "QIIME2")
  
  
  
  ms_prf <- read_ms_results(list.files(path = "data_processed/kozich_2013/results", 
                                 pattern = ".metascope_id.csv", 
                                 full.names = TRUE, 
                                 recursive = TRUE),
                      pipeline = "MetaScope") |>
    tibble::rownames_to_column("taxid") |> 
    pivot_longer(-taxid, names_to = "name", values_to = "value") |>
    group_by(name) |>
    filter(value > abundance_threshold) |>
    mutate(abund_weight = 1 - abs(value - 1/21),
           is_tp = taxid %in% ground_truth_taxonomy_taxids) |> # weight by distance from ground truth abundance
    summarise(
      TP = sum(is_tp),
      precision = TP / n(),
      recall = TP / length(ground_truth_taxonomy_taxids),
      F1 = 2 * precision * recall / (precision + recall)) |>
    mutate(pipeline = "MetaScope")
  
  ms_p_prf <- read_ms_results(list.files(path = "data_processed/kozich_2013/results_priors", 
                                 pattern = ".metascope_id.csv", 
                                 full.names = TRUE, 
                                 recursive = TRUE),
                      pipeline = "MetaScope Priors") |>
    tibble::rownames_to_column("taxid") |> 
    pivot_longer(-taxid, names_to = "name", values_to = "value") |>
    group_by(name) |>
    filter(value > abundance_threshold) |>
    mutate(abund_weight = 1 - abs(value - 1/21),
           is_tp = taxid %in% ground_truth_taxonomy_taxids) |> # weight by distance from ground truth abundance
    summarise(
      TP = sum(is_tp),
      precision = TP / n(),
      recall = TP / length(ground_truth_taxonomy_taxids),
      F1 = 2 * precision * recall / (precision + recall)) |>
    mutate(pipeline = "MetaScope Priors")
  
  ms_p_b_prf <- read_ms_results(list.files(path = "data_processed/kozich_2013/results_metablast_priors_1.0", 
                                 pattern = ".metascope_id.csv", 
                                 full.names = TRUE, 
                                 recursive = TRUE),
                      pipeline = "MetaBlast") |>
    tibble::rownames_to_column("taxid") |> 
    pivot_longer(-taxid, names_to = "name", values_to = "value") |>
    group_by(name) |>
    filter(value > abundance_threshold) |>
    mutate(abund_weight = 1 - abs(value - 1/21),
           is_tp = taxid %in% ground_truth_taxonomy_taxids) |> # weight by distance from ground truth abundance
    summarise(
      TP = sum(is_tp),
      precision = TP / n(),
      recall = TP / length(ground_truth_taxonomy_taxids),
      F1 = 2 * precision * recall / (precision + recall)) |>
    mutate(pipeline = "MetaBlast")
  
  merged_prf <- rbind(dada2_prf, qiime2_prf, ms_prf, ms_p_prf, ms_p_b_prf) |>
    #pivot_longer(cols = c(precision, recall, F1), names_to = "metric_scores", values_to = "value") |>
    select(-TP) |>
    replace_na(list(value = 0))
  merged_prf$pipeline <- factor(merged_prf$pipeline,
                                 levels = c("QIIME2", "DADA2-NB", "MetaScope", 
                                            "MetaScope Priors", "MetaBlast"))
  merged_prf$abundance_threshold <- abundance_threshold
  return(merged_prf)
}


threshold_vals <- c(0,1e-6,5e-6,1e-5,5e-5,1e-4,5e-4,1e-3,5e-3,1e-1,5e-1, 1)
threshold_vals <- seq(0,0.1, 0.001)
pr_curve_df <- map_dfr(threshold_vals,calc_prf)

# Calculate AUC for precision recall curve
aauc <- pr_curve_df |>
  group_by(name, pipeline) |>
  arrange(recall) |>
  summarize(cum_area = trapz(recall, precision)) |>
  ungroup() |>
  group_by(pipeline) |>
  summarize(aauc = mean(cum_area))

# Generate Precision Recall curve
p5<- ggplot(pr_curve_df, aes(x = recall, y = precision, color = name)) + 
  geom_path(show.legend=FALSE) + 
  facet_grid(rows = vars(pipeline)) + 
  geom_text(
    data = aauc, 
    aes(x = 0.125, y = ifelse(aauc>0.5, 0.25, 0.75),
        label = paste0("AAUC = ", round(aauc,3))),
    inherit.aes = FALSE,
    size = 5 / (14/5)
  ) + 
    theme(text=element_text(size=5))

p5

#ggsave(filename="figures/p5_pr_curve.svg", plot=p5, dpi=450, 
#       width=60,height=75,units="mm",device="svg")

pr_curve_df |>
  group_by(name, pipeline) |>
  arrange(recall) |>
  summarize(cum_area = trapz(recall, precision)) |>
  ggplot(aes(x = pipeline, y = cum_area)) + 
  geom_boxplot()
# F1 Curve
max_f1_thresholds <- pr_curve_df |>
  group_by(pipeline, name) |>
  filter(F1 == max(F1, na.rm = TRUE)) |>
  summarise(
    abundance_threshold = mean(abundance_threshold, na.rm = TRUE),
    F1 = F1
  ) |>
  ungroup() |>
  group_by(pipeline) |>
  summarise(abundance_threshold = mean(abundance_threshold), 
            F1 = mean(F1))

p6 <- ggplot(pr_curve_df, aes(x = abundance_threshold, y = F1, color = name)) + 
  geom_path(show.legend=FALSE) + 
  facet_grid(rows = vars(pipeline)) +
  geom_vline(
    data = max_f1_thresholds,
    aes(xintercept = abundance_threshold),
    linetype = "dashed",
    linewidth = 0.5
  )  + 
  geom_text(
    data = max_f1_thresholds, 
    aes(x = abundance_threshold + 0.015, y = ifelse(F1<0.4, 0.7, 0.5) ,
        label = paste0("F1 = ", round(F1,3), "\nThreshold = ", round(abundance_threshold,3))),
    size = 5 / (14/5),
    inherit.aes = FALSE
  ) + 
  geom_vline(
    aes(xintercept = 1/21), 
    linetype = "dotted",
    linewidth = 0.5
  ) +
  theme(text=element_text(size=5))
p6

#ggsave(filename="figures/p6_f1_curve.svg", plot=p6, dpi=450, 
#       width=60,height=75,units="mm",device="svg")

pr_curve_df |> 
  filter(precision == 0, recall == 0) |>
  group_by(pipeline) |>
  summarise(min_abund = min(abundance_threshold), 
            max_abund = max(abundance_threshold))
```

```{r}
pr_curve_df |> 
  mutate(fpr = 1 - recall) |>
  ggplot(aes(x = fpr, y = precision, color = name)) + 
  geom_path() + 
  facet_grid(rows = vars(pipeline))
```
